diff --git a/skeleton/Skeleton.cpp b/skeleton/Skeleton.cpp
index 0bbcb54..ed8eb38 100644
--- a/skeleton/Skeleton.cpp
+++ b/skeleton/Skeleton.cpp
@@ -3,6 +3,8 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/InstrTypes.h"
+#include "llvm/IR/Operator.h"
+#include "llvm/IR/Instructions.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
@@ -11,33 +13,34 @@ using namespace llvm;
 namespace {
   struct SkeletonPass : public FunctionPass {
     static char ID;
-    SkeletonPass() : FunctionPass(ID) {}
+    int countOperator;
+    int countBranch;
+    int countMemory;
+    SkeletonPass() : FunctionPass(ID) {
+      	countOperator=0;
+	countBranch=0;
+	countMemory=0;
+    }
 
+// Reference : http://llvm.org/doxygen/Instruction_8cpp_source.html#l00291
     virtual bool runOnFunction(Function &F) {
       for (auto &B : F) {
         for (auto &I : B) {
           if (auto *op = dyn_cast<BinaryOperator>(&I)) {
-            // Insert at the point where the instruction `op` appears.
-            IRBuilder<> builder(op);
-
-            // Make a multiply with the same operands as `op`.
-            Value *lhs = op->getOperand(0);
-            Value *rhs = op->getOperand(1);
-            Value *mul = builder.CreateMul(lhs, rhs);
-
-            // Everywhere the old instruction was used as an operand, use our
-            // new multiply instruction instead.
-            for (auto &U : op->uses()) {
-              User *user = U.getUser();  // A User is anything with operands.
-              user->setOperand(U.getOperandNo(), mul);
-            }
-
-            // We modified the code.
-            return true;
+          	countOperator++;
+	  }
+	  if(  dyn_cast<BranchInst>(&I) || dyn_cast<TerminatorInst>(&I) ){
+		countBranch++;	
+	  }
+          
+	  if(dyn_cast<AllocaInst>(&I) || dyn_cast<LoadInst>(&I) || dyn_cast<StoreInst>(&I) || dyn_cast<AtomicCmpXchgInst>(&I)  || dyn_cast<AtomicRMWInst>(&I) || dyn_cast<FenceInst>(&I) || dyn_cast<GetElementPtrInst>(&I) ){
+                countMemory++;
           }
-        }
-      }
 
+	  }
+      }
+      errs() << F.getName() << " Operator : " <<  countOperator << " Branch : " << countBranch << " Memory : " << countMemory << "\n";
+      countOperator = 0;countBranch = 0;countMemory=0;
       return false;
     }
   };
@@ -51,6 +54,8 @@ static void registerSkeletonPass(const PassManagerBuilder &,
                          legacy::PassManagerBase &PM) {
   PM.add(new SkeletonPass());
 }
-static RegisterStandardPasses
-  RegisterMyPass(PassManagerBuilder::EP_EarlyAsPossible,
-                 registerSkeletonPass);
+
+// Reference : http://llvm.org/docs/WritingAnLLVMPass.html
+static RegisterPass<SkeletonPass> X("mypass", "My Pass",
+                             false /* Only looks at CFG */,
+                             false /* Analysis Pass */);
